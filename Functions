В роблоксе функции играют основую роль в скриптах
С помощью них можно гибко использовать скрипты, хранить информацию и так далее
Чтобы создать функцию можно использовать такой пример:

function ge()
  print("Test")
end

Или в виде переменной:

ge = function()

end

! end обязательна для границы функции
Чтобы запустить функцию нужно использовать ge():

local function ge()
  print("Test")
end

ge() -- запускает функцию

! Если в функцию поместить запуск саму себя, то это создаст рекурсию и это крашнет клиент
? Если в функции ничего нету, то следовательно функция ничего не сделает
Для функций можно сделать аргументы и с помощью них вписывать значения:

local function ge(arg1)
  print(arg1)
end

ge("Test") -- это запустило print("Test")

? Для функций можно использовать неограниченное количество аргументов
Чтобы использовать несколько аргументов то это можно распределить с помощью запятой:

local function ge(arg1, arg2)
  print(arg1)
  warn(arg2)
end

ge("Test", "Test2") -- это запустило print("Test") и warn("Test 2")

А также можно для обозначения бесконечных аргументов можно использовать vararg:
Для обозначения vararg можно использовать "..."
? Vararg это аргумент который можно использовать неограниченно
? Vararg является таблицой аргументов
! Vararg в аргументах у функции можно использовать только один раз

local function ge(arg1, ...)
  print(arg1)
  warn(...)
end

ge("Test", "Vararg1", "Vararg2", "Vararg3", "Vararginf...")

? Для обозначения vararg (например le =) можно использовать так: le = (...) или le = {...}
? Vararg возвращает массив
Для вывода функции или результата можно использовать "return"

local function ge(a, b)
  return a + b
end

local de = ge(2, 5) -- это запустило 2 + 5 и следом return 2 + 5 и функция вернула 7
print(de) -- 7

! Скрипт после return будет остановлен
! Если просто оставить return то функция будет возвращать ничего
! Если написать print(ge) то это вернёт функцию, а не то что она возвращает
? return возвращает байты в обычный текст 
? В return можно поставить всё что угодно

И return может возвращать несколько значений разделённой запятой:

local function ge()
  return "Alice", 30
end

local name, age = ge()
print(name, age) -- Alice 30

Также функции можно использовать в методах и сигналах у Instances или метаметодов и также использовать для них аргументы:
? Сигнал возвращает ссылку на самого себя

local function ge(hit)
  if part.Parent:FindFirstChildOfClass("Humanoid") then
part.Parent:FindFirstChildOfClass("Humanoid").Health = 0
  end
end

part.Touched:Connect(ge) -- для функции ge сигнал вернул объект который соприкоснулся с part

! Если например сделать так: game.Players.LocalPlayer.Character.Humanoid.Running:Connect(ge(game.Players.LocalPlayer.Character)) то тогда функция запустится, а сигнал выдаст ошибку
? Каждый сигнал возвращает что-то другое

Также у сигналов есть и свои функции:

 Disconnect() – Выключает соеденение с сигналом
 Enable() – Включает сигнал
 Disable() – Выключает сигнал

Вот как можно его выключить или включить:

-- Пример из предыдущего примера скрипта
de = part.Touched:Connect(ge)
de:Disable() -- это остановило сигнал

В роблоксе существуют так сказать анонимные функции:
? Анонимные функции это функции без имени или те которые должны вызваться один раз

part.Touched:Connect(function(part) -- для анонимной функции вернулось значение который вернул сигнал
  print(part:GetFullName())
end)

! Для сигналов с анонимной функции обязательно надо использовать end) с скобкой (закрыть соединение для сигнала)
! Сигнал каждый раз создаёт новую функцию и прошлая остаётся в памяти игры что может повлиять на производительность если играть слишком долго, но а так это безопасно

Для функции можно использовать аргумент в качестве функции:

local function ge(num, callback)
  return callback(num)
end

local de = ge(5, function(e)
   return 8
end)
print(de) -- должно было вернуть 5, но функция вернула 8

У функций есть типы: Lua Closure и C Closure
? Lua Closure это те функции которые написаны на Lua, они более уязвимые для декомпиляции, например ge
? C Closure это те функции которые написаны на C, они менее уязвимые для декомпиляции и они всегда анонимные, например print, getgenv, warn
? Тип функции можно узнать с помощью debug.getinfo(function).short_src или debug.info(function, "s") 
! Lua Closure обозначается пустой строкой

А также немного про факты (термины) о функциях:
 Proto (прототип) – функция которая используется в другой функции
 Upvalues – переменная к которой функция имеет доступ к окружающей среде
 Constant – литеральное значение встроенное в байт код функции
  ! Эти функции не работают на C closure функции
