Циклы в роблоксе имеют большую роль для создания игр, анти читов да и в принципе для скриптов
Есть несколько видов циклов которые выполняют важную роль:

1) while
Эта функция создаёт бесконечный цикл, но скрипт будет запускаться с определённым условием:

while wait(0.5) do
  print("Test")
end

Цикл будет бесконечно повторять скрипт два раза в секунду
! Если в цикле произойдёт хоть одна ошибка, то цикл остановиться
Это можно распознать как "повторять если"
Для начала цикла надо использовать do а для границы использовать end
И для операции нужно использовать C++ знаки такие как: ==, <=, >=

while io == true and wait(0.5) do
  print("Test")
end

Цикл начнётся если io будет true и определённым интервалом в пол секунды
Можно и сделать так чтобы цикл был очень быстрым с помощью task.wait()
? task.wait является аналогом wait но он быстрее и асинхронный

while task.wait() do
  print("Test")
end

Этот цикл будет повторяться более 60 повторений в секунду
! Если указать while true do и в нём не будет задержек то это создаст цикл который будет повторять действие со скоростью бесконечности и таким образом крашнет игру
Но в циклах есть одна проблема: они блокируют основной поток скриптта до тех пор пока он не остановиться:

while task.wait() do print("Test") end
print("Test") -- не запустилось ведь цикл мешает потоку

И поэтому можно использовать task.spawn или spawn
spawn это функция которая создаёт новый поток который находится после основного потока
task.spawn это аналог spawn но тот просто создаёт новый поток который будет находиться там где проставлены границы

task.spawn(function()
 while task.wait() do
  print("Test")
 end
end)
warn("Test") -- запустилось

Да, но это не означает что этот цикл нельзя будет остановить ведь для циклов существует функция break
Её надо использовать в самом цикле:

local num = 0
while task.wait(1) do
  num += 1
print(num)
   if num >= 10 then
 break
   end
end
 print("The cycle has been stopped")
 
Это основное что надо знать о while

2) repeat 
Является аналогом while, но этот цикл остановиться если будет определённое значение и для него не надо использовать do и end:

local num = 0
repeat task.wait(1)
 num += 1
  print(num)
until num >= 10

Он также блокирует основной поток
Его можно распознать как "повторять до тех пор пока"

3) for
А вот тут уже сложно
Этот цикл нужен для итерации объектов: таблиц или просто чисел

for i = 1, 10 do
  print("Repeated 10 times")
end

Для него уже можно не использовать задержки и он тоже может зажержать поток
Можно и в числовой итерации использовать отрицательные числа
? Если в числовой итерации будет не целое число, то оно автоматически округлиться
? В итерации также можно использовать и break
Первый элемент можно использовать как значение для итерации:

for i = 1, 10 do
  print("Repeat already " .. tostring(i) .. " times")
end

Для числовой итерации есть три элемента: минимум (начало), максимум (сколько надо повторять) и промежуток
Например вот как работает промежуток:

for i = 1, 10, 2 do
  print("Repeated already " .. tostring(i) .. " times") -- 1 3 5 7 9
end -- цикл повторился 5 раз

И естественно можно и добавить задержку для итерации:

for i = 1, 2 do
  print(i)
   task.wait(2)
end

Для итерации и циклах есть функция continue
Она представляет собой как условие для цикла:

for i = 1, 10 do
  if i % 2 == 0 then
     continue
 end
  print(i) -- Выполнится только для нечетных чисел
end

Но функцию for можно использовать не только для итерации числа, но и для таблиц
В этом случае нужно использовать два значения и использовать Lua Globals:

local array = {[1] = 10, [2] = 20, [3] = 30}
 for index, value in next, array do
  print(index, value)
 end
 
in обязательна для итерации таблиц
? next это функция которая была создана для итерации таблиц: массивов, словарей и гибридов
? Для отсутствия значения можно использовать "_"
Можно и использовать без next:

for index, value in array do
  print(index, value)
end

Итерация будет полезна над работой с Instance:

for _, player in next, game.Players:GetPlayers() do
  print(player.Name, player.UserId)
end
